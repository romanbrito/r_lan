# Understanding data
glimpse(counties)

# Selecting columns
counties %>% select(state, county, population, poverty)

# Mutate to add varaibles (columns)
counties_selected %>% mutate(unemployed_population = population * unemployment / 100)

# Count to agregate data
counties %>% count() # Total number of observations
counties %>% count(state) # Total number of counties in each state
counties %>% count(state, sort = TRUE) # Sorts in descending order
counties %>% count(state, wt = population, sort = TRUE) # The column n will be weighted by the population; so n will be the total population per state

# group_by, summarize, ungroup
count is a special case of group_by and summarize
Summary functions:
`sum()`
`mean()`
`median()`
`min()`
`max()`
`n()` # count, doesn't need argument

# agregate within groups
counties %>%
  group_by(state) %>%
  summarize(total_pop = sum(population), average_unemployment = mean(unempoyment)) %>%
  arrange(desc(average_unemployment))

# grouping on multiple columns
counties %>%
  group_by(state, metro) %>%
  summarize(total_pop = sum(population)) %>%
# if you don't want to keep state as a group
  ungroup()

# slice_min and slice_max verbs allows us to extract the most extreme observations from each group
counties_selected %>%
  group_by(state) %>%
  slice_max(population, n =1)

counties_selected %>%
  group_by(state) %>%
  slice_min(unemployment, n = 1)

counties_selected %>%
  group_by(state) %>%
  slice_max(unemployment, n = 3) # retrun the 3 counties with the highest unemployment

# select a range of columns
`drive:work_at_home`

counties %>%
  select(state, county, drive:work_at_home) %>%
  arrange(drive)

# selects with contains, starts_with and other helpers 
`?select_helpers`
`contains()`
`starts_with()`
`ends_with()`
`last_col()`
`matches()`

counties %>%
  select(state, county, contains("work")) # all columns that contain "work"

counties %>%
  select(state, county, starts_with("income"))

# Removing a variable 
counties %>%
  select(-census_id)

# The rename verbs (new name = old name)
counties_selected %>% rename(unemployment_rate = unemployment)

# Or combine like this, remember to keep the columns you need
counties_selected %>% select(state, county, population, unemployment_rate = unemployment)

# The transmute verb is like a combination of select() and mutate()
counties %>% transmute(state, county, fraction_men = men / population)

| | Keeps only specified variables | Keeps other varaibles |
| --- | --- | --- |
| Can't change values | select | rename |
| Can change values | transmute | mutate |

# Filter for multiple values
babynames_multiple <- babynames %>%
  filter(name %in% c("Amy", "Christopher"))

# Get most common
babynames %>%
  group_by(name) %>%
  slice_max(number, n = 1)

# Grouped mutates to have a summarized variable side by side
babynames %>%
  group_by(year) %>%
  summarize(year_total = sum(number))

babynames %>%
  group_by(year) %>%
  mutate(year_total = sum(number)) %>%
  ungroup() # good practice to make process faster and we are done with group calculation

# Add the fraction column
babynames %>%
  group_by(year) %>%
  mutate(year_total = sum(number)) %>%
  ungroup() %>%
  mutate(fraction = number / year_total)

# Calculate the fraction of people born each year with the same name
babynames %>%
  group_by(year) %>%
  mutate(year_total = sum(number)) %>%
  ungroup() %>%
  mutate(fraction = number / year_total) %>%
  # Find the year each name is most common
  group_by(name) %>%
  slice_max(fraction, n = 1)

# Group mutate examples

babynames %>%
  # Add columns name_total and name_max for each name
  group_by(name) %>%
  mutate(name_total = sum(number),
         name_max = max(number)) %>%
  # Ungroup the table 
  ungroup() %>%
  # Add the fraction_max column containing the number by the name maximum 
  mutate(fraction_max = number / name_max)


# Visualizing the normalized change in popularity
names_normalized <- babynames %>%
                     group_by(name) %>%
                     mutate(name_total = sum(number),
                            name_max = max(number)) %>%
                     ungroup() %>%
                     mutate(fraction_max = number / name_max)

names_filtered <- names_normalized %>%
  # Filter for the names Steven, Thomas, and Matthew
  filter(name %in% c("Steven", "Thomas", "Matthew"))

# Visualize these names over time
ggplot(names_filtered, aes(x = year, y = fraction_max, color = name)) + geom_line()

# Window function
# Compare consecutive sets
```{r lag_func}
v <- c(1, 3, 6, 14)
v - lag(v)
```
# Changes in popularity
# One name
babynames_fraction %>% 
  filter(name == "Matthew") %>%
  arrange(year) %>%
  mutate(difference = fraction - lag(fraction)) %>%
  arrange(desc(difference))

# Every name
babynames_fraction %>%
  arrange(name, year) %>%
  group_by(name) %>%
  mutate(difference = fraction - lag(fraction)) %>%
  ungroup() %>%
  arrange(desc(difference))